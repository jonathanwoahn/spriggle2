import { IOmnibookData } from "omnibook";

interface IJobLog {
  timestamp: string;
  message: string;
  data?: any;
}

export enum BlockType {
  TEXT = 'text',
  SECTION = 'section',
  BOOK = 'book',
}
// export type IJobStatus = 'pending' | 'processing' | 'completed' | 'failed';
export enum JobStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed',
  WAITING = 'waiting',
}

export enum JobType {
  // BUILD_AUDIOBOOK = 'build-audiobook',
  // First job, which creates all of the jobs needed to create an audio book
  CREATE_JOBS = 'create-jobs',

  // job for each of the text blocks. Generates the audio file, and then creates the text block metadata
  TEXT_TO_AUDIO_META = 'convert-to-audio',

  // job for each of the section blocks. concatenates all of the audio files, and then creates the section block metadata. Also calculates the start time for each text block
  SECTION_CONCAT_META = 'section-concat-meta',

  // Generates a brief summary of the entire book for display to the customer
  BOOK_SUMMARY = 'book-summary',

  // Generates an embedding of the book summary that we can use in the recommendation engine
  SUMMARY_EMBEDDING = 'summary-embedding',

  // job for the book block. calculates the length of the audio book, checks to make sure all of the other jobs are completed, and marks the book as ready or not
  BOOK_META = 'book-meta',
}

export interface IBlockJob {
  status: JobStatus;
  job_type: JobType;
  data: {
    blockId: string;
    bookId: string;
    blockIndex?: number;
    order?: number;
  };
  log: IJobLog[];
  id: string;
  dependencies?: string[];
}

export interface IBlockMetadata {
  id?: number;
  book_id: string;
  block_id: string;
  section_order: number;
  block_index: number;
  type: BlockType;
  data: {
    duration?: number;
    start_time?: number;
    summary?: string;
    ready?: boolean;
  } | IOmnibookData;
  embedding?: number[];
  created_at?: string;
  updated_at?: string;
}

export interface IResponse<T = any> {
  message?: string;
  data?: T;
  status?: number;
}

export interface IBookData {
  cover_image: string;
  uuid: string;
  data: IOmnibookData;
}

/**
 * The different types of licenses represent the end use case of the book content, and how the book blocks are being used by an application
 * 
 */
export enum LicenseType {
  // Conversion of a block to an embedding
  EMBEDDING = 'embedding',

  // The content was used to inform a RAG response
  RAG = 'rag',

  // The content was transcoded into audio
  AUDIO_CONVERSION = 'audio-conversion',

  // The transcoded audio was used for playback
  AUDIO_PLAYBACK = 'audio-playback',

  // The content was used to generate a static summary. Most often associated with "book" and "section" block types.
  STATIC_SUMMARY = 'static-summary',
}
export interface ILicenseReport {
  // UUID of the report, either generated by the API or the client
  id: string;

  // The blockId is the unique identifier of the block that was used, as defined by Cashmere
  blockId: string;

  // The type of license used by the application
  licenseType: LicenseType;

  // The data property is used to store additional information about the license usage
  data?: {
    // In the instance of creating a summary, the "length" property represents the number of characters in the summary
    length?: number;

    // Boolean flag to indicate if the children of the block were included in the license usage
    includedChildren?: boolean;
  };

  // Timestamp of when the license used the block
  timestamp: number;
}

export interface ILicenseResponse {
  // transaction id generated by the API, and record that can be referenced to retrieve all of the license usage information for this transaction
  transactionId: string;

  // the timestamp of the transaction, as generated by the API
  timestamp: number;

  violations?: {
    // The license type that was violated
    licenseType: LicenseType;

    // The blockIds that were violated
    blockIds: string[];

    // message from the server on what went wrong. For instance, the client may not have the license to perform the operation they did
    // or perhaps they did have the license, but the license has expired. Or perhaps they did have the license, but the content has been removed
    // from the API by the creator. We should include information on the course of action the client should take. It should also include information
    // about how long they have to take the corrective action, and how to prevent it from happening in the future
    message: string;

    // just exploring thoughts here. Would be nice if we could programmatically provide them with corrective action, so if the license is denied
    // and they could build out the functionality to automatically process the corrective action.
    correctiveAction: 'remove-content' | 'contact-creator' | 'secure-license-type' | 'update-credit-card' | 'pay-balance';
  }[];
}